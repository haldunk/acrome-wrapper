#+TITLE: Acrome SMD Library Wrapper
#+AUTHOR: Haldun Komsuoglu

This python library is a wrapper for the official [[https://github.com/serhargun/Acrome-SMD][Acrome
SMD python library]]. It provides a formal and object
oriented interface to define, manage and control systems
consisting of SMD modules.

* Questions
** What is the communication protocol between SMD modules?
I2C - ? baud

** What is the function of the SMD RED in the architecture?
** What is the communication protocol between computer and SMD RED?
485 baud =

** What is the physical network topology?
** What is the logical network topology?
** What is the basic architecture of the code base?
** Why are all module functionalities accessed through RED?
** How can one setup a system with multiple REDs (different USB ports, daisy chain, etc.)?
** Is hot swapping possible?
** How are the module indicies defined?
** What is the master.attach and master.detach do?
** What does module scan do?
** How to list all available (discovered) modules and or functionalities?


2-3ms

* Testing

To run basic tests on the library use the [[file:test.py][test.py]]
script. For convenience a make target is provided to run
tests.

#+BEGIN_SRC sh
make test
#+END_SRC

* Use
** Master Setup

The communication between modules and the central computer
is managed by one or more master(s) in the system. The
first step in setting up a system is the decleration and
initialization of all masters available.

For each master in the system a [[file:acrome_wrapper/master.py::class Master(red.Master)][Master]] object instance must
be created. A convenience static method is provided for
this purpose.

Masters can be added one by one which allows setting
seperate baud rates.

#+BEGIN_SRC python
from acrome_wrapper import Master

Master.add('/dev/ttyUSB0', baudrate=112500)
Master.add('/dev/ttyUSB1', baudrate=12500000)
#+END_SRC

Masters can be added in bulk by either using a list of
device paths or a name/device path dictionary. In the
former case the master name is set to the base name of the
device path.

#+BEGIN_SRC python
from acrome_wrapper import Master

Master.add(
  ['/dev/ttyUSB0', '/dev/ttyUSB1'],
  baudrate=112500)

Master.add(
  {'left': '/dev/ttyUSB1', 'right': '/dev/ttyUSB1'},
  baudrate=12500000)
#+END_SRC

** Automatic Module Discovery

Once [[Master Setup][masters in the system are added]] all available modules
can be automatically discovered. This functionality is
provided by the [[file:acrome_wrapper/system.py::def discover][discover() function]] which is defined at
[[file:acrome_wrapper/system.py][system level]].

#+BEGIN_SRC python
from acrome_wrapper import discover

discover()
#+END_SRC

Note that all module names are auto generated by combining
the associated master, module type and module hardware id
which uniquely labels each module.

This function raises [[file:acrome_wrapper/master.py::class NoMasterSetup][NoMasterSetup]] exception if no master
is setup at the time of calling.

The resulting module layout can be printed using another
system level function, [[file:acrome_wrapper/system.py::def layout][layout() function]].

#+BEGIN_SRC python
from acrome_wrapper import layout

layout()
#+END_SRC

** Manual Module Specification

In most cases the system is known by the designer and the
system abstraction can be (and preferrably) set up
manually. This approach allows the designer to specify
human readable and design-level meaningful names to modules
and also store the module instance references in variable.

The manual module decleration uses the [[file:acrome_wrapper/module.py::def add][Module.add()]] static
convenience function. For each module the master, bridging
SMD and the module hardware index needs to be provided. For
motor control module (i.e. the SMD board itself) the
hardware index is omitted as it is not applicable.

#+BEGIN_SRC python
from acrome_wrapper import Master, Module, validate

left_master = Master('/dev/ttyUSB0', name='Left')
right_master = Master('/dev/ttyUSB1', name='Right')

motor_left = Module.add(
  master=master_left, smd_id=0,
  kind=Module.Kind.MOTOR)
motor_right = Module.add(
  master=master_right, smd_id=0,
  kind=Module.Kind.MOTOR)

proximity_left = Module.add(
  master=master_left, smd_id=0,
  kind=Module.Kind.DISTANCE, mod_id=4)
proximity_right = Module.add(
  master=master_right, smd_id=0,
  kind=Module.Kind.DISTANCE, mod_id=2)

validate()
#+END_SRC

The final function call to [[file:acrome_wrapper/system.py::def validate][validate()]] is crucial. It checks
if the specified modules exists in the system and
initializes the master instances for run-time
commpunication.

** Module Hardware Setup
At the start up the setup() method of all modules should be
called. This method executes any required hardware
initialization.

There is a convenience function in the system module to
execute the setup method of all specified modules.

#+BEGIN_SRC python
from acrome_wrapper import setup

setup()
#+END_SRC

** Clearing the Abstraction

The system abstraction, a collection of Master and Module
class instances, can be cleared using convenience
functions.

To clear the entire system use [[file:acrome_wrapper/system.py::def clear][clear()]] function in system
module.


#+BEGIN_SRC python
from acrome_wrapper import clear

clear()
#+END_SRC

Alternatively, you can clear modules and masters individually.

#+BEGIN_SRC python
from acrome_wrapper import Module, Master

Module.clear()
Master.clear()
#+END_SRC

Note that clearing masters but not modules and attempting
to use the module instances will raise exception as there
will not be any communication channel.

** Handling Modules
The [[file:acrome_wrapper/module.py::class Module:][Module]] class provides a collection of static methods to
manage module instances in the system definition.

The [[file:acrome_wrapper/module.py:: def clear][Module.clear()]] clears all defined module instances from
the system abstraction.

#+BEGIN_SRC python
from acrome_wrapper import Module

Module.clear()
#+END_SRC

The [[file:acrome_wrapper/module.py:def all][Module.all()]] returns a list of all module instances
presently defined in the system abstraction.

#+BEGIN_SRC python
from acrome_wrapper import Module

Module.clear()
#+END_SRC

The [[file:acrome_wrapper/module.py::def find][Module.find()]] method is a search tool for module
instances. It can take four optional arguments that serve
as filtering constraints and returns a list of modules that
satisfy these conditions.

#+BEGIN_SRC python
from acrome_wrapper import Module

left_master_modules = Module.find(master=left_master)
motor_modules = Module.find(kind=Module.Kind.MOTOR)
#+END_SRC

Alternatively, one can use [[file:acrome_wrapper/module.py::def get][Module.get()]] metho to get a
single specific module that satisfies a set of
conditions. If the given conditions are satified by
multiple modules a [[file:acrome_wrapper/module.py::class MultipleModulesFound][MultipleModulesFound]] exception is
raised. If no module matches the given conditions
[[file:acrome_wrapper/module.py::class ModuleNotFound][ModuleNotFound]] exception is raised.

#+BEGIN_SRC python
from acrome_wrapper import Module

left_motor = Module.find(name='Left Motor')
#+END_SRC

Each module is given a unique idenfying name. During module
instance creation if this name is not explicitly specified
an automatically generated descriptive name is assigned. By
setting the name property the name of a module can be
changed at any time.


#+BEGIN_SRC python
from acrome_wrapper import Module

left_motor = Module.find(kind=Module.Kind.MOTOR)[0]
left_motor.name = 'Left Motor'
#+END_SRC

** Module Sub Classes
To capture each specialized module implementation a class
is derived from the base Module class. Each child Module
class defines interface and functionality specifically
tailored to the associated module hardware.

*** Motor Modules
[[file:acrome_wrapper/module.py::class Motor][Motor]] modules are DC motor controllers.

* Acrome API
** Master
*** Motor Drive Control
enable_torque(id: int, en: bool)

    Enable power to the motor of the driver.
    
    Args:
        id (int): The device ID of the driver
        en (bool): Enable. True enables the torque.

set_operation_mode(id: int, mode: smd._internals.OperationMode)
    Set the operation mode of the driver.
    
    Args:
        id (int): The device ID of the driver.
        mode (OperationMode): One of the PWM, Position, Velocity, Torque modes.
(END)
  
get_operation_mode(id: int)
  
    Get the current operation mode from the driver.
    
    Args:
        id (int): The device ID of the driver.
    
    Returns:
        list | None: Returns the list containing the operation mode, otherwise None.

        
*** Voltage Mode Control
set_duty_cycle(id: int, pct: float)
  
    Set the duty cycle to the motor for PWM control mode in terms of
    percentage.  Negative values will change the motor direction.
    
    Args:
        id (int): The device ID of the driver.
        pct (int | float): Duty cycle percentage.

*** Speed Mode Control
    def set_shaft_cpr(self, id: int, cpr: float):
        """ Set the count per revolution (CPR) of the motor output shaft.

        Args:
            id (int): The device ID of the driver.
            cpr (float): The CPR value of the output shaft/
        """
        
    def get_shaft_cpr(self, id: int):
        """ Get the count per revolution (CPR) of the motor output shaft.

        Args:
            id (int): The device ID of the driver.

        Returns:
            list | None: Returns the list containing the output shaft CPR, otherwise None.
        """

    def set_shaft_rpm(self, id: int, rpm: float):
        """ Set the revolution per minute (RPM) value of the output shaft at 12V rating.

        Args:
            id (int): The device ID of the driver.
            rpm (float): The RPM value of the output shaft at 12V
        """

    def get_shaft_rpm(self, id: int):
        """ Get the revolution per minute (RPM) value of the output shaft at 12V rating.

        Args:
            id (int): The device ID of the driver.

        Returns:
            list | None: Returns the list containing the output shaft RPM characteristics, otherwise None.
        """

    def set_velocity_limit(self, id: int, vl: int):
        """ Set the velocity limit for the motor output shaft in terms of RPM. The velocity limit
        applies only in velocity mode. Default velocity limit is 65535.

        Args:
            id (int): The device ID of the driver.
            vl (int): New velocity limit (RPM)
        """
        
    def get_velocity_limit(self, id: int):
        """ Get the velocity limit from the driver in terms of RPM.

        Args:
            id (int): The device ID of the driver.

        Returns:
            list | None: Returns the list containing the velocity limit, otherwise None.
        """

    def set_velocity(self, id: int, sp: float):
        """ Set the desired setpoint for the velocity control in terms of RPM.

        Args:
            id (int): The device ID of the driver.
            sp (int | float): Velocity control setpoint.
        """

    def get_velocity(self, id: int):
        """ Get the current velocity of the motor output shaft from the driver in terms of RPM.

        Args:
            id (int): The device ID of the driver.

        Returns:
            list | None: Returns the list containing the current velocity, otherwise None.
        """

    def set_control_parameters_velocity(self, id: int, p=None, i=None, d=None, db=None, ff=None, ol=None):
        """ Set the control block parameters for velocity control mode.
        Only assigned parameters are written, None's are ignored. The default
        max output limit is 950.

        Args:
            id (int): The device ID of the driver.
            p (float): Proportional gain. Defaults to None.
            i (float): Integral gain. Defaults to None.
            d (float): Derivative gain. Defaults to None.
            db (float): Deadband (of the setpoint type). Defaults to None.
            ff (float): Feedforward. Defaults to None.
            ol (float): Maximum output limit. Defaults to None.
        """

    def get_control_parameters_velocity(self, id: int):
        """ Get the velocity control block parameters.

        Args:
            id (int): The device ID of the driver.

        Returns:
            list | None: Returns the list [P, I, D, FF, DB, OUTPUT_LIMIT], otherwise None.
        """
                
* Installation
** Installation from Source
Installation from source requires the source to be compiled
first. To setup the compilation virtual environment run:

#+BEGIN_SRC sh
make venv-setup
#+END_SRC

To compile the source run:

#+BEGIN_SRC sh
make build
#+END_SRC

After the compilation is finalized the resulting package
can be install to the system by running:

#+BEGIN_SRC sh
make install
#+END_SRC

* Releases
** master
- Motor module voltage control mode interface is implemented
** 0.0.0
- Master and Module classes defined.
- Motor and Distance Module classes are started
- system, master and module sources are defined
- General system definition and management is implemented
- Acrome wrapper is turned into a setuptools package
