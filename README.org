* acrome-wrapper

This python library is a wrapper for the official [[https://github.com/serhargun/Acrome-SMD][Acrome
SMD python library]]. It provides a formal and object
oriented interface to define, manage and control systems
consisting of SMD modules.

  - [[file:release.org][Releases]]
  - [[file:acrome_api.org][Acrome API]]

** Installation
*** Installation from Source

Installation from source requires the source to be compiled
first. To setup the compilation virtual environment run:

#+begin_src sh
make venv-setup
#+end_src

To compile the source run:

#+begin_src sh
make build
#+end_src

After the compilation is finalized the resulting package
can be install to the system by running:

#+begin_src sh
make install
#+end_src

** Testing

Enter into the virtual environment before running the test
scripts.

#+begin_src sh
source venv/bin/activate
#+end_src

*** Basic Test

To run basic tests on the library use the [[file:test.py][test.py]]
script. For convenience a make target is provided to run
tests. 

#+begin_src sh
make test
#+end_src

*NOTE:* Basic unit test script is a placeholder at this
 time.

** Use
*** Master Setup

The communication between modules and the central computer
is managed by one or more master(s) in the system. The
first step in setting up a system is the decleration and
initialization of all masters available.

For each master in the system a [[file:acrome_wrapper/master.py::class Master(red.Master)][Master]] object instance must
be created. A convenience static method is provided for
this purpose.

Masters can be added one by one which allows setting
seperate baud rates.

#+begin_src python
from acrome_wrapper import Master

Master.add('/dev/ttyUSB0', baudrate=112500)
Master.add('/dev/ttyUSB1', baudrate=12500000)
#+end_src

Masters can be added in bulk by either using a list of
device paths or a name/device path dictionary. In the
former case the master name is set to the base name of the
device path.

#+begin_src python
from acrome_wrapper import Master

Master.add(
  ['/dev/ttyUSB0', '/dev/ttyUSB1'],
  baudrate=112500)

Master.add(
  {'left': '/dev/ttyUSB1', 'right': '/dev/ttyUSB1'},
  baudrate=12500000)
#+end_src

*** Automatic Module Discovery

Once [[Master Setup][masters in the system are added]] all available modules
can be automatically discovered. This functionality is
provided by the [[file:acrome_wrapper/system.py::def discover][discover() function]] which is defined at
[[file:acrome_wrapper/system.py][system level]].

#+begin_src python
from acrome_wrapper import discover

discover()
#+end_src

Note that all module names are auto generated by combining
the associated master, module type and module hardware id
which uniquely labels each module.

This function raises [[file:acrome_wrapper/master.py::class NoMasterSetup][NoMasterSetup]] exception if no master
is setup at the time of calling.

The resulting module layout can be printed using another
system level function, [[file:acrome_wrapper/system.py::def layout][layout() function]].

#+begin_src python
from acrome_wrapper import layout

layout()
#+end_src

*** Manual Module Specification

In most cases the system is known by the designer and the
system abstraction can be (and preferrably) set up
manually. This approach allows the designer to specify
human readable and design-level meaningful names to modules
and also store the module instance references in variable.

The manual module decleration uses the [[file:acrome_wrapper/module.py::def add][Module.add()]] static
convenience function. For each module the master, bridging
SMD and the module hardware index needs to be provided. For
motor control module (i.e. the SMD board itself) the
hardware index is omitted as it is not applicable.

#+begin_src python
from acrome_wrapper import Master, Module, validate

left_master = Master('/dev/ttyUSB0', name='Left')
right_master = Master('/dev/ttyUSB1', name='Right')

motor_left = Module.add(
  master=master_left, smd_id=0,
  kind=Module.Kind.MOTOR)
motor_right = Module.add(
  master=master_right, smd_id=0,
  kind=Module.Kind.MOTOR)

proximity_left = Module.add(
  master=master_left, smd_id=0,
  kind=Module.Kind.DISTANCE, mod_id=4)
proximity_right = Module.add(
  master=master_right, smd_id=0,
  kind=Module.Kind.DISTANCE, mod_id=2)

validate()
#+end_src

The final function call to [[file:acrome_wrapper/system.py::def validate][validate()]] is crucial. It checks
if the specified modules exists in the system and
initializes the master instances for run-time
commpunication.

*** Module Hardware Setup
At the start up the setup() method of all modules should be
called. This method executes any required hardware
initialization.

There is a convenience function in the system module to
execute the setup method of all specified modules.

#+begin_src python
from acrome_wrapper import setup

setup()
#+end_src

*** Clearing the Abstraction

The system abstraction, a collection of Master and Module
class instances, can be cleared using convenience
functions.

To clear the entire system use [[file:acrome_wrapper/system.py::def clear][clear()]] function in system
module.


#+begin_src python
from acrome_wrapper import clear

clear()
#+end_src

Alternatively, you can clear modules and masters individually.

#+begin_src python
from acrome_wrapper import Module, Master

Module.clear()
Master.clear()
#+end_src

Note that clearing masters but not modules and attempting
to use the module instances will raise exception as there
will not be any communication channel.

*** Handling Modules
The [[file:acrome_wrapper/module.py::class Module:][Module]] class provides a collection of static methods to
manage module instances in the system definition.

The [[file:acrome_wrapper/module.py:: def clear][Module.clear()]] clears all defined module instances from
the system abstraction.

#+begin_src python
from acrome_wrapper import Module

Module.clear()
#+end_src

The [[file:acrome_wrapper/module.py:def all][Module.all()]] returns a list of all module instances
presently defined in the system abstraction.

#+begin_src python
from acrome_wrapper import Module

Module.clear()
#+end_src

The [[file:acrome_wrapper/module.py::def find][Module.find()]] method is a search tool for module
instances. It can take four optional arguments that serve
as filtering constraints and returns a list of modules that
satisfy these conditions.

#+begin_src python
from acrome_wrapper import Module

left_master_modules = Module.find(master=left_master)
motor_modules = Module.find(kind=Module.Kind.MOTOR)
#+end_src

Alternatively, one can use [[file:acrome_wrapper/module.py::def get][Module.get()]] metho to get a
single specific module that satisfies a set of
conditions. If the given conditions are satified by
multiple modules a [[file:acrome_wrapper/module.py::class MultipleModulesFound][MultipleModulesFound]] exception is
raised. If no module matches the given conditions
[[file:acrome_wrapper/module.py::class ModuleNotFound][ModuleNotFound]] exception is raised.

#+begin_src python
from acrome_wrapper import Module

left_motor = Module.find(name='Left Motor')
#+end_src

Each module is given a unique idenfying name. During module
instance creation if this name is not explicitly specified
an automatically generated descriptive name is assigned. By
setting the name property the name of a module can be
changed at any time.


#+begin_src python
from acrome_wrapper import Module

left_motor = Module.find(kind=Module.Kind.MOTOR)[0]
left_motor.name = 'Left Motor'
#+end_src

*** Module Sub Classes
To capture each specialized module implementation a class
is derived from the base Module class. Each child Module
class defines interface and functionality specifically
tailored to the associated module hardware.

**** Motor Modules

[[file:acrome_wrapper/module.py::class Motor][Motor]] modules are DC motor controllers.

