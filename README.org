#+TITLE: acrome-wrapper: An Object Oriented Wrapper for Acrome API
#+AUTHOR: Haldun Komsuoglu

*acrome-wrapper( is a wrapper for the official [[https://github.com/serhargun/Acrome-SMD][Acrome SMD
python library (v1.1.4)]]. It provides a formal and object
oriented interface to define, manage and control systems
consisting of Acrome modules.

See [[file:release.org][Releases]] for a full list of tagged stable versions.

See [[file:docs/acrome_api.org][Acrome API]] for function prototypes and notes on the
underlying Acrome API used in this wrapper implementation.

* Branches

  - *main*: most recent stable version. See [[file:release.org][Releases]] for a
    list of certain milestones of this branch.
  - *devel*: potantially unstable active development branch
    for ongoing code merges
    
* Installation
** From Source

The python packages can be install locally from
source. After cloning the repository build the package and
simply run the install make target.

#+begin_src sh
git clone https://github.com/haldunk/acrome-wrapper.git
cd acrome-wrapper
make venv-setup
make build
make install
#+end_src

** From PyPI

These packages can be installed from pypi by running the
following command:

#+begin_src sh
pip install acrome-wrapper
#+end_src

** From GitHub

Alternatively, you can install directly from the github repository
using the following command:

#+begin_src sh
pip install git+https://github.com/haldunk/acrome-wrapper.git
#+end_src

To install a specific tagged version or a branch use the following
syntax:

#+begin_src sh
pip install git+https://github.com/haldunk/acrome-wrapper.git@<tag|branch>
#+end_src

* Usage
** Master Setup

The communication between modules and the central computer
is managed by one or more master(s) in the system. The
first step in setting up a system is the decleration and
initialization of all masters available.

For each master in the system a [[file:acrome_wrapper/master.py::class Master(red.Master)][Master]] object instance must
be created. A convenience static method is provided for
this purpose.

Masters can be added one by one which allows setting
seperate baud rates.

#+begin_src python
from acrome_wrapper import Master

Master.add('/dev/ttyUSB0', baudrate=112500)
Master.add('/dev/ttyUSB1', baudrate=12500000)
#+end_src

Masters can be added in bulk by either using a list of
device paths or a name/device path dictionary. In the
former case the master name is set to the base name of the
device path.

#+begin_src python
from acrome_wrapper import Master

Master.add(
  ['/dev/ttyUSB0', '/dev/ttyUSB1'],
  baudrate=112500)

Master.add(
  {'left': '/dev/ttyUSB1', 'right': '/dev/ttyUSB1'},
  baudrate=12500000)
#+end_src

** Automatic Module Discovery

Once [[Master Setup][masters in the system are added]] all available modules
can be automatically discovered. This functionality is
provided by the [[file:acrome_wrapper/system.py::def discover][discover() function]] which is defined at
[[file:acrome_wrapper/system.py][system level]].

#+begin_src python
from acrome_wrapper import discover

discover()
#+end_src

Note that all module names are auto generated by combining
the associated master, module type and module hardware id
which uniquely labels each module.

This function raises [[file:acrome_wrapper/master.py::class NoMasterSetup][NoMasterSetup]] exception if no master
is setup at the time of calling.

The resulting module layout can be printed using another
system level function, [[file:acrome_wrapper/system.py::def layout][layout() function]].

#+begin_src python
from acrome_wrapper import layout

layout()
#+end_src

** Manual Module Specification

In most cases the system is known by the designer and the
system abstraction can be (and preferrably) set up
manually. This approach allows the designer to specify
human readable and design-level meaningful names to modules
and also store the module instance references in variable.

The manual module decleration uses the [[file:acrome_wrapper/module.py::def add][Module.add()]] static
convenience function. For each module the master, bridging
SMD and the module hardware index needs to be provided. For
motor control module (i.e. the SMD board itself) the
hardware index is omitted as it is not applicable.

#+begin_src python
from acrome_wrapper import Master, Module, validate

left_master = Master('/dev/ttyUSB0', name='Left')
right_master = Master('/dev/ttyUSB1', name='Right')

motor_left = Module.add(
  master=master_left, smd_id=0,
  kind=Module.Kind.MOTOR)
motor_right = Module.add(
  master=master_right, smd_id=0,
  kind=Module.Kind.MOTOR)

proximity_left = Module.add(
  master=master_left, smd_id=0,
  kind=Module.Kind.DISTANCE, mod_id=4)
proximity_right = Module.add(
  master=master_right, smd_id=0,
  kind=Module.Kind.DISTANCE, mod_id=2)

validate()
#+end_src

The final function call to [[file:acrome_wrapper/system.py::def validate][validate()]] is crucial. It checks
if the specified modules exists in the system and
initializes the master instances for run-time
communication.

** Module Hardware Setup

At the start up the setup() method of all modules should be
called. This method executes any required hardware
initialization.

There is a convenience function in the system module to
execute the setup method of all specified modules.

#+begin_src python
from acrome_wrapper import setup

setup()
#+end_src

** Clearing the Abstraction

The system abstraction, a collection of Master and Module
class instances, can be cleared using convenience
functions.

To clear the entire system use [[file:acrome_wrapper/system.py::def clear][clear()]] function in system
module.


#+begin_src python
from acrome_wrapper import clear

clear()
#+end_src

Alternatively, you can clear modules and masters individually.

#+begin_src python
from acrome_wrapper import Module, Master

Module.clear()
Master.clear()
#+end_src

Note that clearing masters but not modules and attempting
to use the module instances will raise exception as there
will not be any communication channel.

** Module Logistics

The [[file:acrome_wrapper/module.py::class Module:][Module]] class provides a collection of static methods to
manage module instances in the system definition.

The [[file:acrome_wrapper/module.py:: def clear][Module.clear()]] clears all defined module instances from
the system abstraction.

#+begin_src python
from acrome_wrapper import Module

Module.clear()
#+end_src

The [[file:acrome_wrapper/module.py:def all][Module.all()]] returns a list of all module instances
presently defined in the system abstraction.

#+begin_src python
from acrome_wrapper import Module

Module.clear()
#+end_src

The [[file:acrome_wrapper/module.py::def find][Module.find()]] method is a search tool for module
instances. It can take four optional arguments that serve
as filtering constraints and returns a list of modules that
satisfy these conditions.

#+begin_src python
from acrome_wrapper import Module

left_master_modules = Module.find(master=left_master)
motor_modules = Module.find(kind=Module.Kind.MOTOR)
#+end_src

Alternatively, one can use [[file:acrome_wrapper/module.py::def get][Module.get()]] metho to get a
single specific module that satisfies a set of
conditions. If the given conditions are satified by
multiple modules a [[file:acrome_wrapper/module.py::class MultipleModulesFound][MultipleModulesFound]] exception is
raised. If no module matches the given conditions
[[file:acrome_wrapper/module.py::class ModuleNotFound][ModuleNotFound]] exception is raised.

#+begin_src python
from acrome_wrapper import Module

left_motor = Module.get(name='Left Motor')
#+end_src

Specific module classes are captured by their respective
[[Module Sub Classes]]. Each module sub class overrides the
*all*, *find* and *get* static methods to execute the
process limited within their module kind. In other words
using the sub class management command implicitly sets the
kind condition. This is a short form convenience. The
following two approaches both produce the same output.

#+begin_src python
from acrome_wrapper import Motor

gotten_by_motor = Motor.get(mod_id=0)
gotten_by_module = Module.get(kind=Module.Kind.MOTOR, mod_id=0)
#+end_src

Each module is given a unique idenfying name. During module
instance creation if this name is not explicitly specified
an automatically generated descriptive name is assigned. By
setting the name property the name of a module can be
changed at any time.

#+begin_src python
from acrome_wrapper import Module

left_motor = Module.find(kind=Module.Kind.MOTOR)[0]
left_motor.name = 'Left Motor'
#+end_src

Each module is assigned a unique short form *label* which
is compiled using the index of the SMD it is attached to
and the module index. For MOTOR modules (SMD) the label is
the index. For all other modules it is a tuple consisting
of the index of the managing SMD and the index of the
module itself.

Label is sort of an address for the module and can be
accessed using the *label* read-only property.

#+begin_src python
left_motor.label
#+end_src

** Module Sub Classes

To capture each specialized module implementation a class
is derived from the base Module class. Each child Module
class defines interface and functionality specifically
tailored to the associated module hardware.

*** Motor Module

[[file:acrome_wrapper/module.py::class Motor][Motor]] modules are DC motor controllers.

Motor modules can be queried using the *all*, *get* and
*find* specialized static methods like in [[Module Logistics][Module]]s.

#+begin_src python
from acrome_wrapper import Motor

all_motors = Motor.all()

usb0_motors = Motor.find(master=master_usb0)

left_motor = Motor.get(mod_id=0)
right_motor = Motor.get(mod_id=6)
#+end_src

Motor hardware and software information can be queried
using the *get_info* method which will return the version
of the hardware and the firmware of the associated SMD
card.

#+begin_src python
info = motor.get_info()
#+end_src

As in all modules the Motor modules need to be initialized
prior to use. This can be done on an individual basis by
directly calling the *setup()* method as
follows. Alternatively, the system-wide *setup()* function
call would also initialize all Motor modules along with
other modules in the system. Motor module initialization
puts the associated controller in voltage control mode and
sets the terminal voltage to zero.

#+begin_src python
motor.setup()
#+end_src

When the motor is first initialized it is in *Voltage
Control Mode* and the terminal voltage is set to zero and
the motor driver is disabled. This is the /reset state/ for
Motor modules. To bring a Motor module to the Reset State
at any time the *reset()* method can be called.

#+begin_src python
motor.reset()
#+end_src

There are four control modes implemented in the
hardware. These modes are enumurated in the *Motor.Mode*
enumuration.

  - Voltage Control Mode
  - Position Control Mode
  - Velocity Control Mode
  - Torque Control Mode

The /active/ control mode can be queried using the *mode*
property. Setting the same property to the desired
Motor.Mode enumuration value would set the hardware control
mode. Note that when control mode of a Motor module is
changed its motor driver is /disabled/.

#+begin_src python
motor.mode = Motor.Mode.POSITION_CONTROL
print(f"Motor Mode: {motor.mode}")
#+end_src

The motor hardware needs to be *enabled* before use
otherwise control commands will not have any effect and
calling them will produce exception. The activation state
of Motor modules is controlled by two methods: *enable()*
to activate driver; and *disable(()* to deactivate the
driver. The current activation state can be queried using
*is_enabled* property.

#+begin_src python
motor.enable()
motor.disable()
print("Motor State: {}".format(
  'ENABLED' if motor.is_enabled else 'DISABLED'))
#+end_src

**** Voltage Control Mode

In the Voltage Control Mode the motor controller dictates
the terminal voltage of the associated DC motor.

Operations in this mode requires the explicit specification
of the driver supply voltage. The [[file:acrome_wrapper/defaults.py::DEFAULT_SUPPLY_VOLTAGE][default supply voltage]] is
set to 12.0V. If it is different in your system this
property needs to be adjusted. As this is a Motor instance
property it permits different Motors to use different
supply voltage levels. 

#+begin_src python
motor.supply_voltage = 24.0
print(f"Motor Supply Voltage: {motor.supply_voltage:.1f} V")
#+end_src

The motor terminal polarity defines the orientation of the
positive and negative terminals with respect to the motor
driver output terminals. The *polarity* property of the
Motor module can be used to swap terminal orientation
between positive and negative and also to query the active
polarity setting.

#+begin_src python
motor.polarity = Motor.Polarity.NEGATIVE
print(f"Motor Polarity: {motor.polarity}")
#+end_src

To set the terminal voltage set point use *set_voltage()*
function. This method takes the desired terminal voltage in
Volts and applies it to the associated SMD hardare as the
set point after clamping it according to the achivable
voltage range, [-V_supply, V_supply]. Returns the actual
applied voltage set point.  The active motor terminal
voltage set point can be queried using the *get_voltage()*
method.

#+begin_src python
applied_voltage = motor.set_voltage(6.0)
print(f"Motor Terminal Voltage: {motor.get_voltage():.1f}")
#+end_src

Note that the actualy voltage terminal voltage would be
proportional to the actual supply voltage. If the actual
supply voltage deviates from the specified supply voltage
the actual motor terminal voltage will deviate by the same
ratio.

**** Position Control Mode

/To be completed/

**** Velocity Control Mode

/To be completed/

**** Torque Control Mode

/To be completed/

*** Distance Module

[[file:acrome_wrapper/module.py::class Distance][Distance]] modules are ultrasonic distance sensors.

/To be completed/

* Testing

Enter into the virtual environment before running the test
scripts.

#+begin_src sh
source venv/bin/activate
#+end_src

** Basic Test

To run basic tests on the library use the [[file:test.py][test.py]]
script. For convenience a make target is provided to run
tests. 

#+begin_src sh
make test
#+end_src

*NOTE:* Basic unit test script is a placeholder at this
 time.
* Examples

[[file:example/][A collection of simple examples]] are provided to demonstrate
the use of the library functionalities.

The scripts are build based on the following assumptions:

  - There is at least one SMD RED attached to the system
  - Acrome USB gateway is on device ''/dev/ttyUSB0''

The examples are organized to be run in the virtual
environment. Therefore, before running them you must enter
into the virtual environment.

#+begin_src sh
source venv/bin/activate
#+end_src
  
To run a specific example use the following shell command
where ''<script>'' is the name of the example script. 
  
#+begin_src sh
python -m example.<script>
#+end_src

This command must be *executed at the top folder* so that
the acrome_wrapper package is accessible.
